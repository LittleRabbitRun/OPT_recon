/*****************************************************************************
** FILE IDENTIFICATION
**
**      Name:         psfstack_helpers.c (adapted from Jwalls code libfdr2.c)
**      Purpose:      functions for manipulating PSF stack data
**      Programmer:   L.B
**      Date Started: Aug 2011
**
**  This is part of the OPT_RECON program
**  
**
**  This program is free software; you can redistribute it and/or modify
**  it under the terms of the GNU General Public License (version 2) as
**  published by the Free Software Foundation.
**
**  This program is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**  GNU General Public License for more details.
******************************************************************************/
#include "psfstack_helpers.h"

int psfstack_fft(mihandle_t filein, mihandle_t fileout) 
{
 long mz,my,mx;
 long nz,ny,nx;
 long index1, index2, j, i;
 long slice, x,y,z;

 fdr_complex *datain2d = NULL;
 fdr_complex *dataout2d = NULL;

 fdr_complex tmp;
 fftwf_plan plan2d; 

 unsigned long start[3], count[3],nelems;
 float scale;
  
 int result;
  
 result = get_minc_spatial_dimensions_from_handle(filein, &mz, &my, &mx);
 if(result) return 1;
  
 result = get_minc_spatial_dimensions_from_handle(fileout, &nz, &ny, &nx);
 if(result) return 1;
  
 if(mz != nz || my != ny || nx != nx)
 {
  fprintf(stderr, "Dimensions do not match (in: [%ld,%ld,%ld] out: [%ld,%ld,%ld])\n", mz,my,mx, nz,ny,nx);
  return 1;
 }
  
 // Dimensions are the same size, do the transforms!

 datain2d  = (fdr_complex *)fftwf_malloc(mx*my*sizeof(fdr_complex));
 dataout2d = (fdr_complex *)fftwf_malloc(nx*ny*sizeof(fdr_complex));
 
 plan2d = fftwf_plan_dft_2d(my,mx, (fdr_complex *)datain2d, (fdr_complex *)dataout2d, FFTW_FORWARD, FFTW_MEASURE);
  
 /* 
  * First we do a series of 2D FFTs along the z-direction, and store the
  * values in fileout
  */
 for(z=0;z<nz;z++)
 {
   /* 
    * Retrieve the data from the file 
    */
   start[0] = (unsigned long)z; start[1] = start[2] = 0;
   count[0] = 1;
   count[1] = (unsigned long)my;
   count[2] = (unsigned long)mx;
   /*
    * Assume that the filein is real, load it in, then shift to complex
    */
   result = miget_voxel_value_hyperslab(filein,MI_TYPE_FLOAT,start,count, (float *) datain2d);
   if(result == MI_ERROR) 
   {
    fprintf(stderr, "Error getting data.\n");
    return 1;
   }
      
   /* Convert to complex */
   shift_float_to_complex(ny*nx, datain2d);
       
   scale = 1/sqrt(1.0*ny*nx);
   /* Perform the 2D FFT */
   fftwf_execute(plan2d);
          
   // 2D FFT shift
   for(y=0;y<ny/2;y++)
   {
    for(x=0;x<nx/2;x++)
    {
     // swap quadrant 1 and 3
     index1 = y*nx + x;
     index2 = (y+ny/2)*nx + x+nx/2;
     tmp = dataout2d[index1];
     dataout2d[index1] = dataout2d[index2] * scale;
     dataout2d[index2] = tmp * scale;
     // swap quadrant 2 and 4
     index1 = y*nx + (x+nx/2);
     index2 = (y+ny/2)*nx + x;
     tmp = dataout2d[index1];
     dataout2d[index1] = dataout2d[index2] * scale;
     dataout2d[index2] = tmp * scale;
     }
    }
       
  /* Write that out to the file */
  result = miset_voxel_value_hyperslab(fileout,MI_TYPE_FCOMPLEX,start,count,(mifcomplex_t *)dataout2d);
  if(result == MI_ERROR)
  {
   fprintf(stderr, "Error in setting values.\n");
   return 1;
  }
        
 } // end of z loop
  
 fftwf_destroy_plan(plan2d);   
 fftwf_free(datain2d); 
 fftwf_free(dataout2d); 
  
  return 0;
}

int normalize_psfstack(mihandle_t filein, mihandle_t fileout) 
{
 long i, j, k;
 unsigned long start[3], count[3];
 long n3, n2, n1, m3, m2, m1;
 long index, index1, index2;
 float tempsum;
 int result;
 float *data;
 float dmax, dmin;

 dmax = -1e100;
 dmin = 1e100;
 fprintf(stdout, " dimn and max %5.2f %5.2f \n",dmin,dmax);

 result = get_minc_spatial_dimensions_from_handle(filein, &n3, &n2, &n1);
 if(result) return 1;
 
 result = get_minc_spatial_dimensions_from_handle(fileout, &m3, &m2, &m1);
 if(result) return 1;
  if(m3 != n3 || m2 != m2 || m1 != n1)
 {
  fprintf(stdout, "Dimensions do not match up!  exiting ... \n");
  return 1;
 }
 
 data = (float *) fftwf_malloc(n2*n1*sizeof(float));
  
 /* Iterate over depth point */
 for(k=0;k<n3;k++) 
 {
  start[0] = (unsigned long)k;
  start[1] = start[2] = 0;
  count[0] = 1;
  count[1] = (unsigned long) n2; count[2] = (unsigned long)n1;
    
  result = miget_voxel_value_hyperslab(filein,MI_TYPE_FLOAT,start,count, (float *) data);
  if(result == MI_ERROR)
  {
   fftwf_free(data);
   fprintf(stdout, "Could not read data at z=%ld\n", k);
   return 1;
  }
  
    tempsum = 0;
  for(j=0;j<n2;j++) 
  {
   for(i=0;i<n1;i++) 
   {
    index = j*n1 + i;
    tempsum += data[index];
   }
  }
  
  for(j=0;j<n2;j++) 
  {
   for(i=0;i<n1;i++) 
   {
    index = j*n1 + i;
    data[index] /= tempsum;
    if(data[index] < dmin)
     dmin = data[index];
    if(data[index] > dmax)
     dmax = data[index];
   }
  }
  result = miset_voxel_value_hyperslab(fileout,MI_TYPE_FLOAT,start,count, (float *) data);
  if(result == MI_ERROR)
  {
   fftwf_free(data);
   fprintf(stdout, "Could not read data at z=%ld\n", k);
   return 1;
  }
   }

 result = miset_volume_valid_range(fileout, dmax, dmin);
 if(result == MI_ERROR)
 {
  fprintf(stderr, "Could not set volume valid range\n");
  return 1;
 }
 result = miset_volume_range(fileout, dmax, dmin);
 if(result == MI_ERROR)
 {
  fprintf(stderr, "Could not set volume range\n");
  return 1;
 } 

 
 return 0;
}

